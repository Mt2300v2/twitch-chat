<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Twitch Chat Stats - Dark Mode</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background-color: #121212;
      color: #e0e0e0;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      background-color: #1f1f1f;
      color: #e0e0e0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background-color: #333;
    }
    canvas {
      display: none;
      max-width: 800px;
      margin: 20px auto;
      background: #1e1e1e;
      border: 1px solid #333;
      padding: 10px;
    }
  </style>
</head>
<body>
  <h1>Twitch Chat Statistics</h1>
  <div>
    <button onclick="showChart('messagesPerChannel')">Messages per Channel</button>
    <button onclick="showChart('topUsers')">Top Active Users</button>
    <button onclick="showChart('messagesOverTime')">Messages Over Time</button>
    <button onclick="showChart('uniqueUsersPerChannel')">Unique Users per Channel</button>
    <button onclick="showChart('avgMsgLengthPerChannel')">Avg Message Length per Channel</button>
    <button onclick="showChart('messagesByHour')">Messages by Hour</button>
    <button onclick="showChart('messagesByDay')">Messages by Day of Week</button>
    <button onclick="showChart('userFreqDistribution')">User Frequency Distribution</button>
    <button onclick="showChart('channelContribution')">Channel Contribution</button>
    <button onclick="showChart('cumulativeMessagesOverTime')">Cumulative Messages Over Time</button>
    <button onclick="showChart('mostRepeatedWords')">Most Repeated Words</button>
    <button onclick="showChart('leastRepeatedWords')">Least Repeated Words</button>
  </div>
  
  <!-- Canvases for each chart -->
  <canvas id="messagesPerChannel"></canvas>
  <canvas id="topUsers"></canvas>
  <canvas id="messagesOverTime"></canvas>
  <canvas id="uniqueUsersPerChannel"></canvas>
  <canvas id="avgMsgLengthPerChannel"></canvas>
  <canvas id="messagesByHour"></canvas>
  <canvas id="messagesByDay"></canvas>
  <canvas id="userFreqDistribution"></canvas>
  <canvas id="channelContribution"></canvas>
  <canvas id="cumulativeMessagesOverTime"></canvas>
  <canvas id="mostRepeatedWords"></canvas>
  <canvas id="leastRepeatedWords"></canvas>

  <script>
    async function fetchData() {
      const response = await fetch('https://raw.githubusercontent.com/Mt2300v2/twitch-chat/refs/heads/main/chat_logs.csv');
      const text = await response.text();
      // Split by line then by comma.
      return text.split('\n').map(line => line.split(','));
    }

    async function processCSV() {
      const data = await fetchData();
      
      // Initialize data structures for each chart
      const channelCounts = {};
      const userCounts = {};
      const messagesOverTime = {}; // by day
      const uniqueUsersPerChannel = {};
      const totalMsgLength = {}; // total message length per channel
      const msgCountForAvg = {}; // count of messages per channel (for average)
      const messagesByHour = {}; // 0 to 23
      const messagesByDay = {}; // by day of week
      const wordCounts = {}; // for word frequency

      data.forEach(row => {
        if (row.length < 4) return;
        let timestamp = row[0].trim();
        let channel = row[1].trim();
        let user = row[2].trim();
        let message = row[3].trim();
        if (!timestamp) return;

        // Chart 1: Messages per channel
        channelCounts[channel] = (channelCounts[channel] || 0) + 1;
        
        // Chart 2: Active users
        userCounts[user] = (userCounts[user] || 0) + 1;
        
        // Chart 3: Messages over time (by day)
        let date = timestamp.split('T')[0];
        messagesOverTime[date] = (messagesOverTime[date] || 0) + 1;
        
        // Chart 4: Unique users per channel
        if (!uniqueUsersPerChannel[channel]) uniqueUsersPerChannel[channel] = new Set();
        uniqueUsersPerChannel[channel].add(user);
        
        // Chart 5: Average message length per channel
        let msgLen = message.length;
        totalMsgLength[channel] = (totalMsgLength[channel] || 0) + msgLen;
        msgCountForAvg[channel] = (msgCountForAvg[channel] || 0) + 1;
        
        // Chart 6: Messages by hour of day
        let hour = new Date(timestamp).getHours();
        messagesByHour[hour] = (messagesByHour[hour] || 0) + 1;
        
        // Chart 7: Messages by day of the week
        let dayIndex = new Date(timestamp).getDay(); // 0: Sunday, 6: Saturday
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        let dayName = dayNames[dayIndex];
        messagesByDay[dayName] = (messagesByDay[dayName] || 0) + 1;
        
        // Process words for frequency counts (convert to lowercase and match word characters)
        let words = message.toLowerCase().match(/\b\w+\b/g);
        if (words) {
          words.forEach(word => {
            wordCounts[word] = (wordCounts[word] || 0) + 1;
          });
        }
      });

      // Convert sets to counts for unique users per channel
      for (let channel in uniqueUsersPerChannel) {
        uniqueUsersPerChannel[channel] = uniqueUsersPerChannel[channel].size;
      }

      // Calculate average message length per channel (Chart 5)
      const avgMsgLengthPerChannel = {};
      for (let channel in totalMsgLength) {
        avgMsgLengthPerChannel[channel] = totalMsgLength[channel] / msgCountForAvg[channel];
      }

      // Chart 8: User frequency distribution (histogram)
      const maxUserCount = Math.max(...Object.values(userCounts));
      const binCount = 10;
      const binWidth = Math.ceil(maxUserCount / binCount);
      const bins = Array(binCount).fill(0);
      for (let user in userCounts) {
        let count = userCounts[user];
        let binIndex = Math.min(Math.floor(count / binWidth), binCount - 1);
        bins[binIndex]++;
      }
      const binLabels = bins.map((_, i) => `${i * binWidth} - ${((i + 1) * binWidth) - 1}`);

      // Chart 9: Channel contribution (Pie chart: top 10 and the rest grouped)
      const sortedChannels = Object.entries(channelCounts).sort((a, b) => b[1] - a[1]);
      const top10 = sortedChannels.slice(0, 10);
      const others = sortedChannels.slice(10).reduce((acc, cur) => acc + cur[1], 0);
      const channelContributionLabels = top10.map(e => e[0]).concat(['Others']);
      const channelContributionData = top10.map(e => e[1]).concat([others]);

      // Chart 10: Cumulative messages over time
      const sortedDates = Object.keys(messagesOverTime).sort();
      let cumulative = 0;
      const cumulativeData = sortedDates.map(date => {
        cumulative += messagesOverTime[date];
        return cumulative;
      });

      // New Chart 11: Most Repeated Words
      const sortedWords = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);
      const mostRepeated = sortedWords.slice(0, 10);
      
      // New Chart 12: Least Repeated Words (only include words that appear more than once)
      let leastRepeatedCandidates = Object.entries(wordCounts).filter(([word, count]) => count > 1);
      if (leastRepeatedCandidates.length === 0) {
        leastRepeatedCandidates = Object.entries(wordCounts);
      }
      const sortedLeastRepeated = leastRepeatedCandidates.sort((a, b) => a[1] - b[1]);
      const leastRepeated = sortedLeastRepeated.slice(0, 10);

      // Create charts using a generic function
      createChart('messagesPerChannel', 'bar', 'Messages per Channel', getSortedLabelsData(channelCounts, 20));
      createChart('topUsers', 'bar', 'Top Active Users', getSortedLabelsData(userCounts, 10));
      createChart('messagesOverTime', 'line', 'Messages Over Time', getSortedLabelsData(messagesOverTime));
      createChart('uniqueUsersPerChannel', 'bar', 'Unique Users per Channel', getSortedLabelsData(uniqueUsersPerChannel, 20));
      createChart('avgMsgLengthPerChannel', 'bar', 'Average Message Length per Channel', getSortedLabelsData(avgMsgLengthPerChannel, 20));
      createChart('messagesByHour', 'bar', 'Messages by Hour of Day', getSequentialData(messagesByHour, 24, i => i.toString()));
      
      // For days of the week, order manually
      const daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const messagesByDayOrdered = {};
      daysOrder.forEach(day => { messagesByDayOrdered[day] = messagesByDay[day] || 0; });
      createChart('messagesByDay', 'bar', 'Messages by Day of Week', getLabelsDataFromObject(messagesByDayOrdered));
      
      createChart('userFreqDistribution', 'bar', 'User Frequency Distribution', { labels: binLabels, data: bins });
      createChart('channelContribution', 'pie', 'Channel Contribution', { labels: channelContributionLabels, data: channelContributionData });
      createChart('cumulativeMessagesOverTime', 'line', 'Cumulative Messages Over Time', { labels: sortedDates, data: cumulativeData });
      createChart('mostRepeatedWords', 'bar', 'Most Repeated Words', { labels: mostRepeated.map(e => e[0]), data: mostRepeated.map(e => e[1]) });
      createChart('leastRepeatedWords', 'bar', 'Least Repeated Words (min count > 1)', { labels: leastRepeated.map(e => e[0]), data: leastRepeated.map(e => e[1]) });

      // Show the first chart by default
      showChart('messagesPerChannel');
    }

    // Helper functions to structure data for charts
    function getSortedLabelsData(dataObj, limit) {
      let entries = Object.entries(dataObj).sort((a, b) => b[1] - a[1]);
      if (limit) {
        entries = entries.slice(0, limit);
      }
      return { labels: entries.map(e => e[0]), data: entries.map(e => e[1]) };
    }

    function getSequentialData(dataObj, total, labelFunc) {
      const labels = [];
      const data = [];
      for (let i = 0; i < total; i++) {
        labels.push(labelFunc(i));
        data.push(dataObj[i] || 0);
      }
      return { labels, data };
    }

    function getLabelsDataFromObject(dataObj) {
      const labels = Object.keys(dataObj);
      const data = Object.values(dataObj);
      return { labels, data };
    }

    // Function to generate dynamic colors
    function generateColors(count) {
      const colors = [];
      for (let i = 0; i < count; i++) {
        const hue = i * (360 / count);
        colors.push(`hsl(${hue}, 70%, 50%)`);
      }
      return colors;
    }

    // Generic function to create a chart
    function createChart(canvasId, chartType, label, chartData) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      new Chart(ctx, {
        type: chartType,
        data: {
          labels: chartData.labels,
          datasets: [{
            label: label,
            data: chartData.data,
            backgroundColor: chartType === 'pie' ? generateColors(chartData.data.length) : 'rgba(75, 192, 192, 0.5)',
            borderColor: chartType === 'pie' ? generateColors(chartData.data.length) : 'rgba(75, 192, 192, 1)',
            borderWidth: 1,
            fill: chartType === 'line' ? false : true
          }]
        },
        options: { responsive: true }
      });
    }

    // Function to display one chart and hide the others
    function showChart(chartId) {
      document.querySelectorAll('canvas').forEach(canvas => canvas.style.display = 'none');
      document.getElementById(chartId).style.display = 'block';
    }

    // Start processing when the page loads
    processCSV();
  </script>
</body>
</html>
