<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Twitch Chat Stats - Dark Mode</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background-color: #121212;
      color: #e0e0e0;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      background-color: #1f1f1f;
      color: #e0e0e0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background-color: #333;
    }
    canvas {
      display: none;
      max-width: 800px;
      margin: 20px auto;
      background: #1e1e1e;
      border: 1px solid #333;
      padding: 10px;
    }
  </style>
</head>
<body>
  <h1>Twitch Chat Statistics</h1>
  <div>
    <button onclick="showChart('messagesPerChannel')">Messages per Channel</button>
    <button onclick="showChart('topUsers')">Top Active Users</button>
    <button onclick="showChart('messagesOverTime')">Messages Over Time</button>
    <button onclick="showChart('uniqueUsersPerChannel')">Unique Users per Channel</button>
    <button onclick="showChart('avgMsgLengthPerChannel')">Avg Message Length per Channel</button>
    <button onclick="showChart('messagesByHour')">Messages by Hour</button>
    <button onclick="showChart('messagesByDay')">Messages by Day of Week</button>
    <button onclick="showChart('userFreqDistribution')">User Frequency Distribution</button>
    <button onclick="showChart('channelContribution')">Channel Contribution</button>
    <button onclick="showChart('cumulativeMessagesOverTime')">Cumulative Messages Over Time</button>
  </div>
  
  <!-- Canvases for each chart -->
  <canvas id="messagesPerChannel"></canvas>
  <canvas id="topUsers"></canvas>
  <canvas id="messagesOverTime"></canvas>
  <canvas id="uniqueUsersPerChannel"></canvas>
  <canvas id="avgMsgLengthPerChannel"></canvas>
  <canvas id="messagesByHour"></canvas>
  <canvas id="messagesByDay"></canvas>
  <canvas id="userFreqDistribution"></canvas>
  <canvas id="channelContribution"></canvas>
  <canvas id="cumulativeMessagesOverTime"></canvas>

  <script>
    async function fetchData() {
      const response = await fetch('https://raw.githubusercontent.com/Mt2300v2/twitch-chat/refs/heads/main/chat_logs.csv');
      const text = await response.text();
      // Separamos por línea y luego por coma.
      return text.split('\n').map(line => line.split(','));
    }

    async function processCSV() {
      const data = await fetchData();
      
      // Inicializamos las estructuras de datos para cada gráfico
      const channelCounts = {};
      const userCounts = {};
      const messagesOverTime = {}; // Por día
      const uniqueUsersPerChannel = {};
      const totalMsgLength = {}; // Suma de longitudes de mensaje por canal
      const msgCountForAvg = {}; // Conteo de mensajes por canal (para promedio)
      const messagesByHour = {}; // 0 a 23
      const messagesByDay = {}; // Por día de la semana

      data.forEach(row => {
        if (row.length < 4) return;
        let timestamp = row[0].trim();
        let channel = row[1].trim();
        let user = row[2].trim();
        let message = row[3].trim();
        if (!timestamp) return;

        // Gráfico 1: Mensajes por canal
        channelCounts[channel] = (channelCounts[channel] || 0) + 1;
        
        // Gráfico 2: Actividad de usuarios
        userCounts[user] = (userCounts[user] || 0) + 1;
        
        // Gráfico 3: Mensajes a lo largo del tiempo (por día)
        let date = timestamp.split('T')[0];
        messagesOverTime[date] = (messagesOverTime[date] || 0) + 1;
        
        // Gráfico 4: Usuarios únicos por canal
        if (!uniqueUsersPerChannel[channel]) uniqueUsersPerChannel[channel] = new Set();
        uniqueUsersPerChannel[channel].add(user);
        
        // Gráfico 5: Promedio de longitud de mensaje por canal
        let msgLen = message.length;
        totalMsgLength[channel] = (totalMsgLength[channel] || 0) + msgLen;
        msgCountForAvg[channel] = (msgCountForAvg[channel] || 0) + 1;
        
        // Gráfico 6: Mensajes por hora del día
        let hour = new Date(timestamp).getHours();
        messagesByHour[hour] = (messagesByHour[hour] || 0) + 1;
        
        // Gráfico 7: Mensajes por día de la semana
        let dayIndex = new Date(timestamp).getDay(); // 0: Domingo, 6: Sábado
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        let dayName = dayNames[dayIndex];
        messagesByDay[dayName] = (messagesByDay[dayName] || 0) + 1;
      });

      // Convertir sets a conteos en gráfico 4
      for (let channel in uniqueUsersPerChannel) {
        uniqueUsersPerChannel[channel] = uniqueUsersPerChannel[channel].size;
      }

      // Calcular promedio de longitud de mensaje (Gráfico 5)
      const avgMsgLengthPerChannel = {};
      for (let channel in totalMsgLength) {
        avgMsgLengthPerChannel[channel] = totalMsgLength[channel] / msgCountForAvg[channel];
      }

      // Gráfico 8: Distribución de frecuencia de mensajes por usuario (histograma)
      const maxUserCount = Math.max(...Object.values(userCounts));
      const binCount = 10;
      const binWidth = Math.ceil(maxUserCount / binCount);
      const bins = Array(binCount).fill(0);
      for (let user in userCounts) {
        let count = userCounts[user];
        let binIndex = Math.min(Math.floor(count / binWidth), binCount - 1);
        bins[binIndex]++;
      }
      const binLabels = bins.map((_, i) => `${i * binWidth} - ${((i + 1) * binWidth) - 1}`);

      // Gráfico 9: Contribución de canales (Pie chart: top 10 y el resto agrupado)
      const sortedChannels = Object.entries(channelCounts).sort((a, b) => b[1] - a[1]);
      const top10 = sortedChannels.slice(0, 10);
      const others = sortedChannels.slice(10).reduce((acc, cur) => acc + cur[1], 0);
      const channelContributionLabels = top10.map(e => e[0]).concat(['Others']);
      const channelContributionData = top10.map(e => e[1]).concat([others]);

      // Gráfico 10: Mensajes acumulativos a lo largo del tiempo
      const sortedDates = Object.keys(messagesOverTime).sort();
      let cumulative = 0;
      const cumulativeData = sortedDates.map(date => {
        cumulative += messagesOverTime[date];
        return cumulative;
      });

      // Crear gráficos usando una función genérica
      createChart('messagesPerChannel', 'bar', 'Messages per Channel', getSortedLabelsData(channelCounts, 20));
      createChart('topUsers', 'bar', 'Top Active Users', getSortedLabelsData(userCounts, 10));
      createChart('messagesOverTime', 'line', 'Messages Over Time', getSortedLabelsData(messagesOverTime));
      createChart('uniqueUsersPerChannel', 'bar', 'Unique Users per Channel', getSortedLabelsData(uniqueUsersPerChannel, 20));
      createChart('avgMsgLengthPerChannel', 'bar', 'Average Message Length per Channel', getSortedLabelsData(avgMsgLengthPerChannel, 20));
      createChart('messagesByHour', 'bar', 'Messages by Hour of Day', getSequentialData(messagesByHour, 24, i => i.toString()));
      
      // Para los días de la semana, ordenamos manualmente
      const daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const messagesByDayOrdered = {};
      daysOrder.forEach(day => { messagesByDayOrdered[day] = messagesByDay[day] || 0; });
      createChart('messagesByDay', 'bar', 'Messages by Day of Week', getLabelsDataFromObject(messagesByDayOrdered));
      
      createChart('userFreqDistribution', 'bar', 'User Frequency Distribution', { labels: binLabels, data: bins });
      createChart('channelContribution', 'pie', 'Channel Contribution', { labels: channelContributionLabels, data: channelContributionData });
      createChart('cumulativeMessagesOverTime', 'line', 'Cumulative Messages Over Time', { labels: sortedDates, data: cumulativeData });
    }

    // Funciones auxiliares para estructurar datos
    function getSortedLabelsData(dataObj, limit) {
      let entries = Object.entries(dataObj).sort((a, b) => b[1] - a[1]);
      if (limit) {
        entries = entries.slice(0, limit);
      }
      return { labels: entries.map(e => e[0]), data: entries.map(e => e[1]) };
    }

    function getSequentialData(dataObj, total, labelFunc) {
      const labels = [];
      const data = [];
      for (let i = 0; i < total; i++) {
        labels.push(labelFunc(i));
        data.push(dataObj[i] || 0);
      }
      return { labels, data };
    }

    function getLabelsDataFromObject(dataObj) {
      const labels = Object.keys(dataObj);
      const data = Object.values(dataObj);
      return { labels, data };
    }

    // Función para generar colores dinámicamente
    function generateColors(count) {
      const colors = [];
      for (let i = 0; i < count; i++) {
        const hue = i * (360 / count);
        colors.push(`hsl(${hue}, 70%, 50%)`);
      }
      return colors;
    }

    // Función genérica para crear un gráfico
    function createChart(canvasId, chartType, label, chartData) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      new Chart(ctx, {
        type: chartType,
        data: {
          labels: chartData.labels,
          datasets: [{
            label: label,
            data: chartData.data,
            backgroundColor: chartType === 'pie' ? generateColors(chartData.data.length) : 'rgba(75, 192, 192, 0.5)',
            borderColor: chartType === 'pie' ? generateColors(chartData.data.length) : 'rgba(75, 192, 192, 1)',
            borderWidth: 1,
            fill: chartType === 'line' ? false : true
          }]
        },
        options: { responsive: true }
      });
    }

    // Función para mostrar un gráfico y ocultar los demás
    function showChart(chartId) {
      document.querySelectorAll('canvas').forEach(canvas => canvas.style.display = 'none');
      document.getElementById(chartId).style.display = 'block';
    }

    // Inicia el procesamiento cuando la página se carga
    processCSV();
  </script>
</body>
</html>
