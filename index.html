<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Twitch Chat Stats - Dark Mode</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background-color: #121212;
      color: #e0e0e0;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      background-color: #1f1f1f;
      color: #e0e0e0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background-color: #333;
    }
    canvas {
      display: none;
      max-width: 800px;
      margin: 20px auto;
      background: #1e1e1e;
      border: 1px solid #333;
      padding: 10px;
    }
    #loading-bar-container {
      width: 100%;
      height: 20px;
      background-color: #333;
      margin: 20px 0;
    }
    #loading-bar {
      height: 100%;
      background-color: #4caf50;
      width: 0%;
    }
  </style>
</head>
<body>
  <h1>Twitch Chat Statistics</h1>
  <div>
    <button onclick="showChart('messagesPerChannel')">Messages per Channel</button>
    <button onclick="showChart('topUsers')">Top Active Users</button>
    <button onclick="showChart('messagesOverTime')">Messages Over Time</button>
    <button onclick="showChart('uniqueUsersPerChannel')">Unique Users per Channel</button>
    <button onclick="showChart('avgMsgLengthPerChannel')">Avg Message Length per Channel</button>
    <button onclick="showChart('messagesByHour')">Messages by Hour</button>
    <button onclick="showChart('messagesByDay')">Messages by Day of Week</button>
    <button onclick="showChart('userFreqDistribution')">User Frequency Distribution</button>
    <button onclick="showChart('channelContribution')">Channel Contribution</button>
    <button onclick="showChart('cumulativeMessagesOverTime')">Cumulative Messages Over Time</button>
    <button onclick="showChart('mostRepeatedWords')">Most Repeated Words</button>
    <button onclick="showChart('leastRepeatedWords')">Least Repeated Words</button>
  </div>
  
  <!-- Loading Bar -->
  <div id="loading-bar-container">
    <div id="loading-bar"></div>
  </div>

  <!-- Canvases for each chart -->
  <canvas id="messagesPerChannel"></canvas>
  <canvas id="topUsers"></canvas>
  <canvas id="messagesOverTime"></canvas>
  <canvas id="uniqueUsersPerChannel"></canvas>
  <canvas id="avgMsgLengthPerChannel"></canvas>
  <canvas id="messagesByHour"></canvas>
  <canvas id="messagesByDay"></canvas>
  <canvas id="userFreqDistribution"></canvas>
  <canvas id="channelContribution"></canvas>
  <canvas id="cumulativeMessagesOverTime"></canvas>
  <canvas id="mostRepeatedWords"></canvas>
  <canvas id="leastRepeatedWords"></canvas>

  <script>
    async function fetchData() {
      const response = await fetch('https://raw.githubusercontent.com/Mt2300v2/twitch-chat/refs/heads/main/chat_logs.csv');
      const text = await response.text();
      return text.split('\n').map(line => line.split(','));
    }

    async function processCSV() {
      const data = await fetchData();
      
      const channelCounts = {};
      const userCounts = {};
      const messagesOverTime = {};
      const uniqueUsersPerChannel = {};
      const totalMsgLength = {};
      const msgCountForAvg = {};
      const messagesByHour = {};
      const messagesByDay = {};
      const wordCounts = {};
      
      let processedRows = 0;
      const totalRows = data.length;

      // Function to update the loading bar
      function updateLoadingBar() {
        const percentage = (processedRows / totalRows) * 100;
        document.getElementById('loading-bar').style.width = percentage + '%';
      }

      for (let rowIndex = 0; rowIndex < totalRows; rowIndex++) {
        let row = data[rowIndex];
        if (row.length < 4) continue;
        let timestamp = row[0].trim();
        let channel = row[1].trim();
        let user = row[2].trim();
        let message = row[3].trim();
        if (!timestamp) continue;

        // Processing for each chart
        channelCounts[channel] = (channelCounts[channel] || 0) + 1;
        userCounts[user] = (userCounts[user] || 0) + 1;
        let date = timestamp.split('T')[0];
        messagesOverTime[date] = (messagesOverTime[date] || 0) + 1;

        if (!uniqueUsersPerChannel[channel]) uniqueUsersPerChannel[channel] = new Set();
        uniqueUsersPerChannel[channel].add(user);

        let msgLen = message.length;
        totalMsgLength[channel] = (totalMsgLength[channel] || 0) + msgLen;
        msgCountForAvg[channel] = (msgCountForAvg[channel] || 0) + 1;

        let hour = new Date(timestamp).getHours();
        messagesByHour[hour] = (messagesByHour[hour] || 0) + 1;

        let dayIndex = new Date(timestamp).getDay();
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        let dayName = dayNames[dayIndex];
        messagesByDay[dayName] = (messagesByDay[dayName] || 0) + 1;

        let words = message.toLowerCase().match(/\b\w+\b/g);
        if (words) {
          words.forEach(word => {
            wordCounts[word] = (wordCounts[word] || 0) + 1;
          });
        }

        processedRows++;
        updateLoadingBar();

        // Optionally, you can add a delay here to avoid blocking the main thread
        // await new Promise(resolve => setTimeout(resolve, 0));  // Uncomment for throttling
      }

      // Continue processing after all rows are read
      for (let channel in uniqueUsersPerChannel) {
        uniqueUsersPerChannel[channel] = uniqueUsersPerChannel[channel].size;
      }

      const avgMsgLengthPerChannel = {};
      for (let channel in totalMsgLength) {
        avgMsgLengthPerChannel[channel] = totalMsgLength[channel] / msgCountForAvg[channel];
      }

      const maxUserCount = Math.max(...Object.values(userCounts));
      const binCount = 10;
      const binWidth = Math.ceil(maxUserCount / binCount);
      const bins = Array(binCount).fill(0);
      for (let user in userCounts) {
        let count = userCounts[user];
        let binIndex = Math.min(Math.floor(count / binWidth), binCount - 1);
        bins[binIndex]++;
      }
      const binLabels = bins.map((_, i) => `${i * binWidth} - ${((i + 1) * binWidth) - 1}`);

      const sortedChannels = Object.entries(channelCounts).sort((a, b) => b[1] - a[1]);
      const top10 = sortedChannels.slice(0, 10);
      const others = sortedChannels.slice(10).reduce((acc, cur) => acc + cur[1], 0);
      const channelContributionLabels = top10.map(e => e[0]).concat(['Others']);
      const channelContributionData = top10.map(e => e[1]).concat([others]);

      const sortedDates = Object.keys(messagesOverTime).sort();
      let cumulative = 0;
      const cumulativeData = sortedDates.map(date => {
        cumulative += messagesOverTime[date];
        return cumulative;
      });

      const sortedWords = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);
      const mostRepeated = sortedWords.slice(0, 10);

      let leastRepeatedCandidates = Object.entries(wordCounts).filter(([word, count]) => count > 1);
      if (leastRepeatedCandidates.length === 0) {
        leastRepeatedCandidates = Object.entries(wordCounts);
      }
      const sortedLeastRepeated = leastRepeatedCandidates.sort((a, b) => a[1] - b[1]);
      const leastRepeated = sortedLeastRepeated.slice(0, 10);

      createChart('messagesPerChannel', 'bar', 'Messages per Channel', getSortedLabelsData(channelCounts, 20));
      createChart('topUsers', 'bar', 'Top Active Users', getSortedLabelsData(userCounts, 10));
      createChart('messagesOverTime', 'line', 'Messages Over Time', getSortedLabelsData(messagesOverTime));
      createChart('uniqueUsersPerChannel', 'bar', 'Unique Users per Channel', getSortedLabelsData(uniqueUsersPerChannel, 20));
      createChart('avgMsgLengthPerChannel', 'bar', 'Average Message Length per Channel', getSortedLabelsData(avgMsgLengthPerChannel, 20));
      createChart('messagesByHour', 'bar', 'Messages by Hour of Day', getSequentialData(messagesByHour, 24, i => i.toString()));

      const daysOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const messagesByDayOrdered = {};
      daysOrder.forEach(day => { messagesByDayOrdered[day] = messagesByDay[day] || 0; });
      createChart('messagesByDay', 'bar', 'Messages by Day of Week', getLabelsDataFromObject(messagesByDayOrdered));

      createChart('userFreqDistribution', 'bar', 'User Frequency Distribution', { labels: binLabels, data: bins });
      createChart('channelContribution', 'pie', 'Channel Contribution', { labels: channelContributionLabels, data: channelContributionData });
      createChart('cumulativeMessagesOverTime', 'line', 'Cumulative Messages Over Time', { labels: sortedDates, data: cumulativeData });
      createChart('mostRepeatedWords', 'bar', 'Most Repeated Words', { labels: mostRepeated.map(e => e[0]), data: mostRepeated.map(e => e[1]) });
      createChart('leastRepeatedWords', 'bar', 'Least Repeated Words (min count > 1)', { labels: leastRepeated.map(e => e[0]), data: leastRepeated.map(e => e[1]) });

      showChart('messagesPerChannel');
    }

    function getSortedLabelsData(dataObj, limit) {
      let entries = Object.entries(dataObj).sort((a, b) => b[1] - a[1]);
      if (limit) {
        entries = entries.slice(0, limit);
      }
      return { labels: entries.map(e => e[0]), data: entries.map(e => e[1]) };
    }

    function getSequentialData(dataObj, total, labelFunc) {
      const labels = [];
      const data = [];
      for (let i = 0; i < total; i++) {
        labels.push(labelFunc(i));
        data.push(dataObj[i] || 0);
      }
      return { labels, data };
    }

    function getLabelsDataFromObject(dataObj) {
      const labels = Object.keys(dataObj);
      const data = Object.values(dataObj);
      return { labels, data };
    }

    function generateColors(count) {
      const colors = [];
      for (let i = 0; i < count; i++) {
        const hue = i * (360 / count);
        colors.push(`hsl(${hue}, 70%, 50%)`);
      }
      return colors;
    }

    function createChart(canvasId, chartType, label, chartData) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      new Chart(ctx, {
        type: chartType,
        data: {
          labels: chartData.labels,
          datasets: [{
            label: label,
            data: chartData.data,
            backgroundColor: chartType === 'pie' ? generateColors(chartData.data.length) : 'rgba(75, 192, 192, 0.5)',
            borderColor: chartType === 'pie' ? generateColors(chartData.data.length) : 'rgba(75, 192, 192, 1)',
            borderWidth: 1,
            fill: chartType === 'line' ? false : true
          }]
        },
        options: { responsive: true }
      });
    }

    function showChart(chartId) {
      document.querySelectorAll('canvas').forEach(canvas => canvas.style.display = 'none');
      document.getElementById(chartId).style.display = 'block';
    }

    processCSV();
  </script>
</body>
</html>
